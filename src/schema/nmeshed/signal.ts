// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Answer, AnswerT } from '../nmeshed/answer.js';
import { Candidate, CandidateT } from '../nmeshed/candidate.js';
import { Join, JoinT } from '../nmeshed/join.js';
import { Offer, OfferT } from '../nmeshed/offer.js';
import { SignalData, unionToSignalData, unionListToSignalData } from '../nmeshed/signal-data.js';


export class Signal implements flatbuffers.IUnpackableObject<SignalT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Signal {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSignal(bb:flatbuffers.ByteBuffer, obj?:Signal):Signal {
  return (obj || new Signal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSignal(bb:flatbuffers.ByteBuffer, obj?:Signal):Signal {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Signal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

toPeer():string|null
toPeer(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
toPeer(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

fromPeer():string|null
fromPeer(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
fromPeer(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

dataType():SignalData {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : SignalData.NONE;
}

data<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

static startSignal(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addToPeer(builder:flatbuffers.Builder, toPeerOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, toPeerOffset, 0);
}

static addFromPeer(builder:flatbuffers.Builder, fromPeerOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, fromPeerOffset, 0);
}

static addDataType(builder:flatbuffers.Builder, dataType:SignalData) {
  builder.addFieldInt8(2, dataType, SignalData.NONE);
}

static addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, dataOffset, 0);
}

static endSignal(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createSignal(builder:flatbuffers.Builder, toPeerOffset:flatbuffers.Offset, fromPeerOffset:flatbuffers.Offset, dataType:SignalData, dataOffset:flatbuffers.Offset):flatbuffers.Offset {
  Signal.startSignal(builder);
  Signal.addToPeer(builder, toPeerOffset);
  Signal.addFromPeer(builder, fromPeerOffset);
  Signal.addDataType(builder, dataType);
  Signal.addData(builder, dataOffset);
  return Signal.endSignal(builder);
}

unpack(): SignalT {
  return new SignalT(
    this.toPeer(),
    this.fromPeer(),
    this.dataType(),
    (() => {
      const temp = unionToSignalData(this.dataType(), this.data.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })()
  );
}


unpackTo(_o: SignalT): void {
  _o.toPeer = this.toPeer();
  _o.fromPeer = this.fromPeer();
  _o.dataType = this.dataType();
  _o.data = (() => {
      const temp = unionToSignalData(this.dataType(), this.data.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
}
}

export class SignalT implements flatbuffers.IGeneratedObject {
constructor(
  public toPeer: string|Uint8Array|null = null,
  public fromPeer: string|Uint8Array|null = null,
  public dataType: SignalData = SignalData.NONE,
  public data: AnswerT|CandidateT|JoinT|OfferT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const toPeer = (this.toPeer !== null ? builder.createString(this.toPeer!) : 0);
  const fromPeer = (this.fromPeer !== null ? builder.createString(this.fromPeer!) : 0);
  const data = builder.createObjectOffset(this.data);

  return Signal.createSignal(builder,
    toPeer,
    fromPeer,
    this.dataType,
    data
  );
}
}
