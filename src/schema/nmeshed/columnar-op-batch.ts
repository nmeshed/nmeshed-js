// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { ValueBlob, ValueBlobT } from '../nmeshed/value-blob.js';


export class ColumnarOpBatch implements flatbuffers.IUnpackableObject<ColumnarOpBatchT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ColumnarOpBatch {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsColumnarOpBatch(bb:flatbuffers.ByteBuffer, obj?:ColumnarOpBatch):ColumnarOpBatch {
  return (obj || new ColumnarOpBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsColumnarOpBatch(bb:flatbuffers.ByteBuffer, obj?:ColumnarOpBatch):ColumnarOpBatch {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ColumnarOpBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

workspaceId():string|null
workspaceId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
workspaceId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

keys(index: number):string
keys(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
keys(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

keysLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

timestamps(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

timestampsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

values(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

valuesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

valuesArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

valueBlobs(index: number, obj?:ValueBlob):ValueBlob|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new ValueBlob()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

valueBlobsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

actorIdxs(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

actorIdxsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

actorIdxsArray():Uint32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

seqs(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

seqsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

isDeletes(index: number):boolean|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
}

isDeletesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

isDeletesArray():Int8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startColumnarOpBatch(builder:flatbuffers.Builder) {
  builder.startObject(8);
}

static addWorkspaceId(builder:flatbuffers.Builder, workspaceIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, workspaceIdOffset, 0);
}

static addKeys(builder:flatbuffers.Builder, keysOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, keysOffset, 0);
}

static createKeysVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startKeysVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTimestamps(builder:flatbuffers.Builder, timestampsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, timestampsOffset, 0);
}

static createTimestampsVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startTimestampsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addValues(builder:flatbuffers.Builder, valuesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, valuesOffset, 0);
}

static createValuesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startValuesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addValueBlobs(builder:flatbuffers.Builder, valueBlobsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, valueBlobsOffset, 0);
}

static createValueBlobsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startValueBlobsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addActorIdxs(builder:flatbuffers.Builder, actorIdxsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, actorIdxsOffset, 0);
}

static createActorIdxsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createActorIdxsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createActorIdxsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]!);
  }
  return builder.endVector();
}

static startActorIdxsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSeqs(builder:flatbuffers.Builder, seqsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, seqsOffset, 0);
}

static createSeqsVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startSeqsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addIsDeletes(builder:flatbuffers.Builder, isDeletesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, isDeletesOffset, 0);
}

static createIsDeletesVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]!);
  }
  return builder.endVector();
}

static startIsDeletesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endColumnarOpBatch(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createColumnarOpBatch(builder:flatbuffers.Builder, workspaceIdOffset:flatbuffers.Offset, keysOffset:flatbuffers.Offset, timestampsOffset:flatbuffers.Offset, valuesOffset:flatbuffers.Offset, valueBlobsOffset:flatbuffers.Offset, actorIdxsOffset:flatbuffers.Offset, seqsOffset:flatbuffers.Offset, isDeletesOffset:flatbuffers.Offset):flatbuffers.Offset {
  ColumnarOpBatch.startColumnarOpBatch(builder);
  ColumnarOpBatch.addWorkspaceId(builder, workspaceIdOffset);
  ColumnarOpBatch.addKeys(builder, keysOffset);
  ColumnarOpBatch.addTimestamps(builder, timestampsOffset);
  ColumnarOpBatch.addValues(builder, valuesOffset);
  ColumnarOpBatch.addValueBlobs(builder, valueBlobsOffset);
  ColumnarOpBatch.addActorIdxs(builder, actorIdxsOffset);
  ColumnarOpBatch.addSeqs(builder, seqsOffset);
  ColumnarOpBatch.addIsDeletes(builder, isDeletesOffset);
  return ColumnarOpBatch.endColumnarOpBatch(builder);
}

unpack(): ColumnarOpBatchT {
  return new ColumnarOpBatchT(
    this.workspaceId(),
    this.bb!.createScalarList<string>(this.keys.bind(this), this.keysLength()),
    this.bb!.createScalarList<bigint>(this.timestamps.bind(this), this.timestampsLength()),
    this.bb!.createScalarList<number>(this.values.bind(this), this.valuesLength()),
    this.bb!.createObjList<ValueBlob, ValueBlobT>(this.valueBlobs.bind(this), this.valueBlobsLength()),
    this.bb!.createScalarList<number>(this.actorIdxs.bind(this), this.actorIdxsLength()),
    this.bb!.createScalarList<bigint>(this.seqs.bind(this), this.seqsLength()),
    this.bb!.createScalarList<boolean>(this.isDeletes.bind(this), this.isDeletesLength())
  );
}


unpackTo(_o: ColumnarOpBatchT): void {
  _o.workspaceId = this.workspaceId();
  _o.keys = this.bb!.createScalarList<string>(this.keys.bind(this), this.keysLength());
  _o.timestamps = this.bb!.createScalarList<bigint>(this.timestamps.bind(this), this.timestampsLength());
  _o.values = this.bb!.createScalarList<number>(this.values.bind(this), this.valuesLength());
  _o.valueBlobs = this.bb!.createObjList<ValueBlob, ValueBlobT>(this.valueBlobs.bind(this), this.valueBlobsLength());
  _o.actorIdxs = this.bb!.createScalarList<number>(this.actorIdxs.bind(this), this.actorIdxsLength());
  _o.seqs = this.bb!.createScalarList<bigint>(this.seqs.bind(this), this.seqsLength());
  _o.isDeletes = this.bb!.createScalarList<boolean>(this.isDeletes.bind(this), this.isDeletesLength());
}
}

export class ColumnarOpBatchT implements flatbuffers.IGeneratedObject {
constructor(
  public workspaceId: string|Uint8Array|null = null,
  public keys: (string)[] = [],
  public timestamps: (bigint)[] = [],
  public values: (number)[] = [],
  public valueBlobs: (ValueBlobT)[] = [],
  public actorIdxs: (number)[] = [],
  public seqs: (bigint)[] = [],
  public isDeletes: (boolean)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const workspaceId = (this.workspaceId !== null ? builder.createString(this.workspaceId!) : 0);
  const keys = ColumnarOpBatch.createKeysVector(builder, builder.createObjectOffsetList(this.keys));
  const timestamps = ColumnarOpBatch.createTimestampsVector(builder, this.timestamps);
  const values = ColumnarOpBatch.createValuesVector(builder, this.values);
  const valueBlobs = ColumnarOpBatch.createValueBlobsVector(builder, builder.createObjectOffsetList(this.valueBlobs));
  const actorIdxs = ColumnarOpBatch.createActorIdxsVector(builder, this.actorIdxs);
  const seqs = ColumnarOpBatch.createSeqsVector(builder, this.seqs);
  const isDeletes = ColumnarOpBatch.createIsDeletesVector(builder, this.isDeletes);

  return ColumnarOpBatch.createColumnarOpBatch(builder,
    workspaceId,
    keys,
    timestamps,
    values,
    valueBlobs,
    actorIdxs,
    seqs,
    isDeletes
  );
}
}
